{
    "pattern_name": "precise_code_snippet_extractor",
    "description": "Extract a precise code snippet from a file by function, class, or line range using AST or line ranges. Used for robust, programmatic extraction of code for documentation, analysis, or refactoring.",
    "source_file": "c:\\Projects\\MCP Server\\src\\toolz.py",
    "function_name": "get_snippet",
    "source_code": "def get_snippet(request: SnippetRequest) -> dict:\n    \"\"\"\n    Extract a precise code snippet from a file by function, class, or line range.\n\n    This tool allows you to programmatically extract:\n      - The full source of a named function (including decorators and signature)\n      - The full source of a named class (including decorators and signature)\n      - An arbitrary range of lines from any text file\n\n    Args:\n        request (SnippetRequest):\n            - file_path (str): Absolute path to the file to extract from. Must be within the project root.\n            - mode (str): Extraction mode. One of:\n                * 'function': Extract a named function by its name.\n                * 'class': Extract a named class by its name.\n                * 'lines': Extract a specific line range.\n            - name (str, optional): Required for 'function' and 'class' modes. The name of the function or class to extract.\n            - start_line (int, optional): Required for 'lines' mode. 1-indexed starting line.\n            - end_line (int, optional): Required for 'lines' mode. 1-indexed ending line (inclusive).\n\n    Returns:\n        dict: Structured JSON response with status and result:\n            - status (str): 'success', 'error', or 'not_found'\n            - snippet (str, optional): The extracted code snippet (if found)\n            - message (str): Human-readable status or error message\n\n    Usage Examples:\n        # Extract a function\n        {\n            \"file_path\": \"/project/src/foo.py\",\n            \"mode\": \"function\",\n            \"name\": \"my_func\"\n        }\n        # Extract lines 10-20\n        {\n            \"file_path\": \"/project/src/foo.py\",\n            \"mode\": \"lines\",\n            \"start_line\": 10,\n            \"end_line\": 20\n        }\n\n    Notes:\n        - Returns an error if the file is outside the project root or does not exist.\n        - For 'function' and 'class', uses Python AST for precise extraction.\n        - For 'lines', both start and end are inclusive and 1-indexed.\n    \"\"\"\n    import pathlib\n    logger = globals().get('logger', None)\n    try:\n        path = pathlib.Path(request.file_path)\n        if not _is_safe_path(path):\n            msg = f\"Unsafe or out-of-project file path: {request.file_path}\"\n            if logger: logger.error(f\"[get_snippet] {msg}\")\n            return {\"status\": \"error\", \"message\": msg}\n        if not path.exists():\n            msg = f\"File does not exist: {request.file_path}\"\n            if logger: logger.error(f\"[get_snippet] {msg}\")\n            return {\"status\": \"error\", \"message\": msg}\n        source = path.read_text(encoding=\"utf-8\")\n        if request.mode in (\"function\", \"class\"):\n            if not request.name:\n                return {\"status\": \"error\", \"message\": f\"'name' must be provided for mode '{request.mode}'\"}\n            try:\n                tree = ast.parse(source, filename=str(path))\n                for node in ast.walk(tree):\n                    if request.mode == \"function\" and isinstance(node, ast.FunctionDef) and node.name == request.name:\n                        snippet = ast.get_source_segment(source, node)\n                        if snippet:\n                            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Function extracted.\"}\n                        else:\n                            return {\"status\": \"not_found\", \"message\": \"Function found but could not extract source.\"}\n                    if request.mode == \"class\" and isinstance(node, ast.ClassDef) and node.name == request.name:\n                        snippet = ast.get_source_segment(source, node)\n                        if snippet:\n                            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Class extracted.\"}\n                        else:\n                            return {\"status\": \"not_found\", \"message\": \"Class found but could not extract source.\"}\n                return {\"status\": \"not_found\", \"message\": f\"No {request.mode} named '{request.name}' found.\"}\n            except Exception as e:\n                if logger: logger.error(f\"[get_snippet] AST parse error: {e}\")\n                return {\"status\": \"error\", \"message\": f\"AST parse error: {e}\"}\n        elif request.mode == \"lines\":\n            if request.start_line is None or request.end_line is None:\n                return {\"status\": \"error\", \"message\": \"start_line and end_line must be provided for 'lines' mode.\"}\n            lines = source.splitlines()\n            # 1-indexed, inclusive\n            if request.start_line < 1 or request.end_line > len(lines) or request.start_line > request.end_line:\n                return {\"status\": \"error\", \"message\": \"Invalid line range.\"}\n            snippet = \"\\n\".join(lines[request.start_line - 1:request.end_line])\n            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Lines extracted.\"}\n        else:\n            return {\"status\": \"error\", \"message\": f\"Invalid mode: {request.mode}.\"}\n    except Exception as e:\n        if logger: logger.error(f\"[get_snippet] Unexpected error: {e}\")\n        return {\"status\": \"error\", \"message\": f\"Unexpected error: {e}\"}",
    "added_at_utc": "2025-07-13T03:35:58Z"
}