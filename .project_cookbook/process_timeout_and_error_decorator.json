{
    "pattern_name": "process_timeout_and_error_decorator",
    "description": "Decorator for running a function in a separate process with a hard timeout, returning structured error dicts on timeout or exception. Ensures MCP tool reliability.",
    "source_file": "c:\\Projects\\MCP Server\\src\\toolz.py",
    "function_name": "tool_process_timeout_and_errors",
    "source_code": "def tool_process_timeout_and_errors(timeout=60):\n    \"\"\"\n    Decorator to run a function in a separate process with a hard timeout and robust error handling.\n    Returns MCP-protocol-compliant error dicts on timeout or exception.\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            def target_fn(q, *a, **k):\n                try:\n                    result = func(*a, **k)\n                    q.put((\"success\", result))\n                except Exception as e:\n                    tb = traceback.format_exc()\n                    q.put((\"error\", {\"status\": \"error\", \"message\": str(e), \"traceback\": tb}))\n            q = multiprocessing.Queue()\n            p = multiprocessing.Process(target=target_fn, args=(q, *args), kwargs=kwargs)\n            p.start()\n            try:\n                status, result = q.get(timeout=timeout)\n                p.join(1)\n                if status == \"success\":\n                    return result\n                else:\n                    logging.error(f\"[tool_process_timeout_and_errors] Tool error: {result.get('message')}\")\n                    return result\n            except Exception as e:\n                p.terminate()\n                logging.error(f\"[tool_process_timeout_and_errors] Tool timed out or crashed: {e}\")\n                return {\"status\": \"error\", \"message\": f\"Tool timed out after {timeout} seconds or crashed.\", \"exception\": str(e)}\n        return wrapper\n    return decorator",
    "added_at_utc": "2025-07-09T04:18:26Z"
}