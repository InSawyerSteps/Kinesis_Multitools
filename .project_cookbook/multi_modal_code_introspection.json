{
    "pattern_name": "multi_modal_code_introspection",
    "description": "Multi-modal code/project introspection multitool for fast, read-only analysis of code and config files. Supports config, outline, stats, and inspect modes for robust project analysis.",
    "source_file": "c:\\Projects\\MCP Server\\src\\toolz.py",
    "function_name": "introspect",
    "source_code": "def introspect(request: IntrospectRequest) -> dict:\n    \"\"\"\n    Multi-modal code/project introspection multitool for fast, read-only analysis of code and config files.\n\n    This tool provides several sub-tools (modes) for lightweight, high-speed codebase introspection:\n\n    Modes:\n        - 'config':\n            * Reads project configuration files (pyproject.toml or requirements.txt).\n            * Args: config_type ('pyproject' or 'requirements').\n            * Returns: For 'pyproject', the full TOML text. For 'requirements', a list of package strings.\n        - 'outline':\n            * Returns a high-level structural map of a Python file: all top-level functions and classes (with their methods).\n            * Args: file_path (str)\n            * Returns: functions (list), classes (list of {name, methods})\n        - 'stats':\n            * Calculates basic file statistics: total lines, code lines, comment lines, file size in bytes.\n            * Args: file_path (str)\n            * Returns: total_lines (int), code_lines (int), comment_lines (int), file_size_bytes (int)\n        - 'inspect':\n            * Provides details about a single function or class in a file: name, arguments/methods, docstring.\n            * Args: file_path (str), function_name (str, optional), class_name (str, optional)\n            * Returns: type ('function' or 'class'), name, args/methods, docstring\n\n    Args:\n        request (IntrospectRequest):\n            - mode (str): One of 'config', 'outline', 'stats', 'inspect'.\n            - file_path (str, optional): Path to the file for inspection (required for all except config).\n            - config_type (str, optional): 'pyproject' or 'requirements' for config mode.\n            - function_name (str, optional): Name of function to inspect (for 'inspect' mode).\n            - class_name (str, optional): Name of class to inspect (for 'inspect' mode).\n\n    Returns:\n        dict: Structured JSON response. Always includes:\n            - status (str): 'success', 'error', or 'not_found'\n            - message (str): Human-readable status or error message\n        Mode-specific fields:\n            - config: config_type, content (str) or packages (list)\n            - outline: functions (list), classes (list of {name, methods})\n            - stats: total_lines, code_lines, comment_lines, file_size_bytes\n            - inspect: type, name, args/methods, docstring\n\n    Usage Examples:\n        # Get outline of a file\n        {\n            \"mode\": \"outline\",\n            \"file_path\": \"/project/src/foo.py\"\n        }\n        # Inspect a function\n        {\n            \"mode\": \"inspect\",\n            \"file_path\": \"/project/src/foo.py\",\n            \"function_name\": \"my_func\"\n        }\n        # Get requirements\n        {\n            \"mode\": \"config\",\n            \"config_type\": \"requirements\"\n        }\n\n    Notes:\n        - All file paths are validated for project safety.\n        - All operations are fast and read-only (no mutation, no heavy analysis).\n        - Returns 'not_found' if the target file, function, or class does not exist.\n    \"\"\"\n    import pathlib, ast, os, json\n    logger = globals().get('logger', None)\n    try:\n        # --- config mode ---\n        if request.mode == \"config\":\n            if request.config_type not in (\"pyproject\", \"requirements\"):\n                return {\"status\": \"error\", \"message\": \"config_type must be 'pyproject' or 'requirements' for config mode.\"}\n            root = next(iter(PROJECT_ROOTS.values()), None)\n            if not root:\n                return {\"status\": \"error\", \"message\": \"No project root found.\"}\n            if request.config_type == \"pyproject\":\n                cfg_path = pathlib.Path(root) / \"pyproject.toml\"\n                if not cfg_path.exists():\n                    return {\"status\": \"not_found\", \"message\": \"pyproject.toml not found.\"}\n                content = cfg_path.read_text(encoding=\"utf-8\")\n                return {\"status\": \"success\", \"config_type\": \"pyproject\", \"content\": content}\n            elif request.config_type == \"requirements\":\n                req_path = pathlib.Path(root) / \"requirements.txt\"\n                if not req_path.exists():\n                    return {\"status\": \"not_found\", \"message\": \"requirements.txt not found.\"}\n                lines = req_path.read_text(encoding=\"utf-8\").splitlines()\n                pkgs = [l.strip() for l in lines if l.strip() and not l.strip().startswith(\"#\")]\n                return {\"status\": \"success\", \"config_type\": \"requirements\", \"packages\": pkgs}\n\n        # --- outline, stats, inspect modes require file_path ---\n        if not request.file_path:\n            return {\"status\": \"error\", \"message\": \"file_path must be provided for this mode.\"}\n        path = pathlib.Path(request.file_path)\n        if not _is_safe_path(path):\n            msg = f\"Unsafe or out-of-project file path: {request.file_path}\"\n            if logger: logger.error(f\"[introspect] {msg}\")\n            return {\"status\": \"error\", \"message\": msg}\n        if not path.exists():\n            return {\"status\": \"not_found\", \"message\": f\"File does not exist: {request.file_path}\"}\n        source = path.read_text(encoding=\"utf-8\")\n\n        # --- outline mode ---\n        if request.mode == \"outline\":\n            try:\n                tree = ast.parse(source, filename=str(path))\n                functions = []\n                classes = []\n                for node in tree.body:\n                    if isinstance(node, ast.FunctionDef):\n                        functions.append(node.name)\n                    elif isinstance(node, ast.ClassDef):\n                        cls = {\"name\": node.name, \"methods\": [n.name for n in node.body if isinstance(n, ast.FunctionDef)]}\n                        classes.append(cls)\n                return {\"status\": \"success\", \"functions\": functions, \"classes\": classes}\n            except Exception as e:\n                if logger: logger.error(f\"[introspect] AST parse error: {e}\")\n                return {\"status\": \"error\", \"message\": f\"AST parse error: {e}\"}\n\n        # --- stats mode ---\n        elif request.mode == \"stats\":\n            lines = source.splitlines()\n            total_lines = len(lines)\n            comment_lines = sum(1 for l in lines if l.strip().startswith(\"#\"))\n            code_lines = sum(1 for l in lines if l.strip() and not l.strip().startswith(\"#\"))\n            file_size_bytes = os.path.getsize(str(path))\n            return {\n                \"status\": \"success\",\n                \"total_lines\": total_lines,\n                \"code_lines\": code_lines,\n                \"comment_lines\": comment_lines,\n                \"file_size_bytes\": file_size_bytes\n            }\n\n        # --- inspect mode ---\n        elif request.mode == \"inspect\":\n            if not request.function_name and not request.class_name:\n                return {\"status\": \"error\", \"message\": \"Must provide function_name or class_name for inspect mode.\"}\n            try:\n                tree = ast.parse(source, filename=str(path))\n                # Inspect function\n                if request.function_name:\n                    for node in ast.walk(tree):\n                        if isinstance(node, ast.FunctionDef) and node.name == request.function_name:\n                            args = [a.arg for a in node.args.args]\n                            doc = ast.get_docstring(node)\n                            return {\n                                \"status\": \"success\",\n                                \"type\": \"function\",\n                                \"name\": node.name,\n                                \"args\": args,\n                                \"docstring\": doc\n                            }\n                # Inspect class\n                if request.class_name:\n                    for node in ast.walk(tree):\n                        if isinstance(node, ast.ClassDef) and node.name == request.class_name:\n                            doc = ast.get_docstring(node)\n                            methods = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]\n                            return {\n                                \"status\": \"success\",\n                                \"type\": \"class\",\n                                \"name\": node.name,\n                                \"methods\": methods,\n                                \"docstring\": doc\n                            }\n                return {\"status\": \"not_found\", \"message\": \"Requested function/class not found.\"}\n            except Exception as e:\n                if logger: logger.error(f\"[introspect] AST parse error: {e}\")\n                return {\"status\": \"error\", \"message\": f\"AST parse error: {e}\"}\n\n        else:\n            return {\"status\": \"error\", \"message\": f\"Invalid mode: {request.mode}.\"}\n    except Exception as e:\n        if logger: logger.error(f\"[introspect] Unexpected error: {e}\")\n        return {\"status\": \"error\", \"message\": f\"Unexpected error: {e}\"}\n\n    import pathlib\n    logger = globals().get('logger', None)\n    try:\n        path = pathlib.Path(request.file_path)\n        if not _is_safe_path(path):\n            msg = f\"Unsafe or out-of-project file path: {request.file_path}\"\n            if logger: logger.error(f\"[get_snippet] {msg}\")\n            return {\"status\": \"error\", \"message\": msg}\n        if not path.exists():\n            msg = f\"File does not exist: {request.file_path}\"\n            if logger: logger.error(f\"[get_snippet] {msg}\")\n            return {\"status\": \"error\", \"message\": msg}\n        source = path.read_text(encoding=\"utf-8\")\n        if request.mode in (\"function\", \"class\"):\n            if not request.name:\n                return {\"status\": \"error\", \"message\": f\"'name' must be provided for mode '{request.mode}'\"}\n            try:\n                tree = ast.parse(source, filename=str(path))\n                for node in ast.walk(tree):\n                    if request.mode == \"function\" and isinstance(node, ast.FunctionDef) and node.name == request.name:\n                        snippet = ast.get_source_segment(source, node)\n                        if snippet:\n                            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Function extracted.\"}\n                        else:\n                            return {\"status\": \"not_found\", \"message\": \"Function found but could not extract source.\"}\n                    if request.mode == \"class\" and isinstance(node, ast.ClassDef) and node.name == request.name:\n                        snippet = ast.get_source_segment(source, node)\n                        if snippet:\n                            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Class extracted.\"}\n                        else:\n                            return {\"status\": \"not_found\", \"message\": \"Class found but could not extract source.\"}\n                return {\"status\": \"not_found\", \"message\": f\"No {request.mode} named '{request.name}' found.\"}\n            except Exception as e:\n                if logger: logger.error(f\"[get_snippet] AST parse error: {e}\")\n                return {\"status\": \"error\", \"message\": f\"AST parse error: {e}\"}\n        elif request.mode == \"lines\":\n            if request.start_line is None or request.end_line is None:\n                return {\"status\": \"error\", \"message\": \"start_line and end_line must be provided for 'lines' mode.\"}\n            lines = source.splitlines()\n            # 1-indexed, inclusive\n            if request.start_line < 1 or request.end_line > len(lines) or request.start_line > request.end_line:\n                return {\"status\": \"error\", \"message\": \"Invalid line range.\"}\n            snippet = \"\\n\".join(lines[request.start_line - 1:request.end_line])\n            return {\"status\": \"success\", \"snippet\": snippet, \"message\": \"Lines extracted.\"}\n        else:\n            return {\"status\": \"error\", \"message\": f\"Invalid mode: {request.mode}.\"}\n    except Exception as e:\n        if logger: logger.error(f\"[get_snippet] Unexpected error: {e}\")\n        return {\"status\": \"error\", \"message\": f\"Unexpected error: {e}\"}",
    "added_at_utc": "2025-07-13T03:36:00Z"
}